## TODO
Remember to check all prints Ive added to Litex build, since some of them change stuff (like rom loading)
https://github.com/trustedcomputinggroup/tpm

-- Starting litex
mkdir project-petalite
cd project-petalite
python3 -m venv venv
source venv/bin/activate
mkdir litex
cd litex
wget https://raw.githubusercontent.com/enjoy-digital/litex/master/litex_setup.py
chmod +x litex_setup.py
python3 ./litex_setup.py --init --install --config=full

cd ..
pip3 install meson ninja
sudo ./litex/litex_setup.py --gcc=riscv
pip3 install litex/litex -- looks redundant but is necessary
source /tools/Xilinx/Vivado/2024.2/settings64.sh


-- Chipyard:
1. Install conda
2. Run sudo apt-get install linux-image-generic
sudo apt install libguestfs-tools
3. Run installation as per documentation
4. source /home/franos/chipyard/env.sh


-- Vivado
sudo apt-get update
sudo apt-get install locales
sudo locale-gen en_US.UTF-8
sudo update-locale
source /tools/Xilinx/Vivado/2024.2/settings64.sh
source /tools/Xilinx/2025.1.1/Vivado/settings64.sh
vivado&


-- GTKWave
sudo apt install build-essential meson gperf flex desktop-file-utils libgtk-3-dev libbz2-dev libjudy-dev libgirepository1.0-dev
sudo apt install libgtk-4-dev
git clone "https://github.com/gtkwave/gtkwave.git"
cd gtkwave
sudo meson setup build && cd build && meson install


-- Yosis
source /home/franos/projects/project-petalite/tools/oss-cad-suite/environment


-- To run QuestaSim in Vivado:
1. Install the correct version of QuestaSim, which is 2024.1

1. Install compatible version of gcc, which for Questa 2024.1, is 7.4.
    1.1. Read https://chatgpt.com/c/68378209-0244-800a-b94b-61cb9fc717f0

sudo update-alternatives --config gcc

2. Change /home/franos/intelFPGA_pro/24.2/questa_fse/bin/vcom to add:
+elif echo "$@" | grep -q -- "-version" ; then
+  exec "$arg0" "$@" | sed 's@ Intel Starter FPGA Edition@Sim@'
around line 180, right at the end, or so.

3. In Vivado, go to Tools, Compile Simulation libs

4. Wait for compilation (around 1:20h or so)

5. Set:
export PATH=$PATH:/home/franos/intelFPGA_pro/24.2/questa_fse/bin
export LM_LICENSE_FILE=/home/franos/intelFPGA_pro/LR-236507_License.dat:$LM_LICENSE_FILE
::env(LM_LICENSE_FILE)  "/home/franos/intelFPGA_pro/LR-236507_License.dat"
puts $::env(LM_LICENSE_FILE)


-- Verilator
1. Follow tutorial in https://verilator.org/guide/latest/install.html, using Install into a Specific Prefix
2. Then do export PATH="/tools/verilator/v5.036-48-g0dc93c1d5/bin:$PATH"


# Commands
source /tools/Xilinx/2025.1.1/Vivado/settings64.sh
export PATH="/tools/verilator/v5.036-48-g0dc93c1d5/bin:$PATH"

./build.sh
./build.sh --force-all
./soc/petalite.py --sim --io-json=soc/data/io_sim.json --build-dir=builds/soc --compile-gateware --firmware=builds/firmware.bin --load
OPTIONALLY: --load --trace --debug-bridge

./build.sh --board
./build.sh --force-all --board
./soc/petalite.py --build-dir=builds/soc --compile-gateware --firmware=builds/firmware.bin
OPTIONALLY: --load --trace --debug-bridge

BOARD IS xc7vx690tffg1761-3

MORE COMMANDS:
litex_server --udp --udp-ip=192.168.1.50
litex_cli --csr-csv="./builds/soc/csr.csv" --regs
gtkwave ./builds/soc/gateware/sim.fst
./firmware/firmware.py show

-- Adding swap mem to SoC:
sudo swapoff -a
sudo rm /swapfile
sudo fallocate -l 64G /swapfile
sudo chmod 600 /swapfile
sudo mkswap /swapfile
sudo swapon /swapfile
free -h


-- USB access in WSL:
winget install --interactive --exact dorssel.usbipd-win
usbipd list
usbipd bind --busid <busid>
usbipd attach --wsl --busid <busid>
lsusb (in linux)

Also, install Xilinx drivers:
cd <Vivado Install>/data/xicom/cable_drivers/lin64/install_script/install_drivers/
sudo ./install_drivers

cd builds/soc/gateware
vivado&
open_project digilent_netfpga_sume.xpr
open_checkpoint ./digilent_netfpga_sume_route.dcp

# Debugging
15h... got to 0xea... stopped
running for 4h10min, currently in 0c-3

We need to implement the shims in tpm_to_platform_interface.h AND ONLY THOSE (as far as I can tell)
There are other _plat funcs, but they are for simulation purposes.
Actually... some of the ones in platform_public_interface need to be CONCEPTUALLY implemented
That is, we might need to have StartUp implemented as deasserting the SoC reset for example.
But the function calls themselves dont seem all that necessary?
They also seem to implement vars (like s_isCanceled) that need to be signals in the SoC itself... we might need some HAL here
About this last topic (s_isCanceled and such), ask Copilot to summarize it for me
Finally, we need to wrap the TPM command with a one (?) byte header, so we can also transmit stuff needed for the side-band (i.e. Cancel request, Locality, _TPM_Hash_Start)
That is, if we still want to use UART, which seems like the safer bet. Otherwise, we would have to deal with
how to share a bus between the TPM and the host in Litex (which might be possible, but still), and that would break our
qemu simulation architecture... so best to stick to UART.


