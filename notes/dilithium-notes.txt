- We had to extend the max command size to 8kb, since a Dilithium sig can be bigger than 4kB

- Because the sign operation hashes the message with the sk, we need a HashSign opcode
- Because the message can be arbitrarily long, we actually need HashSignStart and HashSignContinue

- Specifically due to the way our core works, its also easier for the Verify op to take the message itself
- Because of that, ans again the arbitrary size, we need the opcodes HashVerifyStart and HashVerifyContinue
- If not for our specific core, we could first hash the message/pk with SHAKE to get mu, and then use that to perform the remaining verify step

- For now, lets start with mono commands, without the Sequence logic. Then we can add that.

- We should change, at least the opcode, to be in the vendor commands, even if were not using vendor structures


- We should probably change the DMA engine so we dont need to do stuff 64 bit aligned, or at least have the option not to.
That way, we can get the sk from its original buffer, instead of first transfering it into the dilithium buffer.
We need to think carefully about this, but I tyhink it works.
That way the output also doesnt need to be 64 bit aligned maybe? But that seems less important.
The other option is transferring the sk and the message into a 64 bit aligned scratchpad (the dilithium buffer, which
will need to be bigger to support bigger message lengths coming from the tpm commands), which is less efficient.
NOTE: we are currently doing the second option cause thats quicker