# Random notes

# Choice of CPU
- Currently, we are using Rocket since its 64 bit, and the DIlithium module is 64 bits.
- We could try using VexRiscV and using a bus converter instead
- Actually, when we change the bus to 64, it breaks the simulation, but it works in the original simulation script
- I think its because the gateware is being instantiated for 32 bits. Need to debug that.
- Try to run my design without dilithium, with a 64 bus. Also, try to do the step by step simulation with 64 bits.
- So, aparently whats causing the problem is reisizing the rom when we pass the rom init content. We solve it by commenting the last line in the SoC constructor:
        # ROM.
        # Initialize ROM from binary file when provided.
        if isinstance(integrated_rom_init, str):
            integrated_rom_init = get_mem_data(integrated_rom_init,
                endianness = "little", # FIXME: Depends on CPU.
                data_width = bus_data_width
            )
            # integrated_rom_size = 4*len(integrated_rom_init)

- But I should stillt ry to understand if this is indeed a mistake in Litex, and why it doesnt happen when using litex_sim. But I think I can leave that for later

- Currently, even though bus is 64 bits wide, data is being loaded 32 bits at a time, on the LSB.
- Maybe simulation isnt being run for enough time, or signals are switched. Compare to Vivado.
- Maybe h test vectors have been wrongly copied in dilithium-comparison. Check that.
- Depending on the TPM specs, we might need two uarts... one for control signals, the other for data
- That would be needed if the specs say that we should be able to stop an operation midway through, for example
That might cause the firmware libs to break, but we can probably solve it.

- We had to change this part of Litex a bit so we could map the crypto buffer in IO space
- Which is not ideal... but when we put it out of that space, the firmware could not access those positions

    def add_ram(self, name, origin, size, contents=[], mode="rwx", custom: bool = False):
        print("CUSTOOOM")
        ram_cls = {
            "wishbone": wishbone.SRAM,
            "axi-lite": axi.AXILiteSRAM,
            "axi"     : axi.AXILiteSRAM, # FIXME: Use AXI-Lite for now, create AXISRAM.
        }[self.bus.standard]
        interface_cls = {
            "wishbone": wishbone.Interface,
            "axi-lite": axi.AXILiteInterface,
            "axi"     : axi.AXILiteInterface, # FIXME: Use AXI-Lite for now, create AXISRAM.
        }[self.bus.standard]
        ram_bus = interface_cls(
            data_width    = self.bus.data_width,
            address_width = self.bus.address_width,
            bursting      = self.bus.bursting
        )
        ram = ram_cls(size, bus=ram_bus, init=contents, read_only=("w" not in mode), name=name)
        region = SoCRegion(origin=origin, size=size, mode=mode, cached=(not custom), linker=custom)
        self.bus.add_slave(name=name, slave=ram.bus, region=region)

- Also changed serial2tcp to increase buffer size
  - That didnt seem to make a diff though